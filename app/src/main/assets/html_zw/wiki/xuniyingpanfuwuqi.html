<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>虛擬硬盤服務器</title>

  <link rel='stylesheet' id='publishable-mag-style-css' href='mycss1.css' type='text/css' media='all' />




</head>

<body class="single single-post postid-14455 single-format-standard">
  

            <!-- Start Title -->
            <h1 class="title single-title">虛擬硬盤服務器</h1>
            <!-- End Title -->
        
          <div id="content" class="post-single-content box mark-links">
        
        <!--<p class="yellow"><b>此頁面的部分內容由於太久沒更新而已過期</b>
<br />
你可以幫助我們來更新此頁面
</p>
<p class="yellow">
<b>此頁面的(部分)內容需要被翻譯</b>
<br />
你可以幫助我們來翻譯此頁面
       </p> -->
<p class="red"><b>警告</b>
<br />
因為這是 Wiki 的一個條目，可以在任何時間內被任何人編輯，因此建議你不要完全使用這個腳本，而是將其當作編寫腳本的指導手冊看待。</p> 


<p>該教程向你大概描述什麼是虛擬硬盤，怎樣和 Minecraft 使用，以及如何設置一個虛擬硬盤服務器。</p>
 
<h2>虛擬硬盤描述</h2>
<p>傳統上，文件和文件夾儲存在硬盤驅動器，但以今天的標準來看，普通數據的傳輸速度(80MB/秒 到 200MB/秒之間)的提升空間還很大。虛擬硬盤是一個虛擬的文件系統(不像硬盤那樣是硬件)，會把文件數據完全實時儲存在計算機內存條里。它們的普通數據傳輸速度(3000MB/秒 到 15000MB/秒之間)非常高，但會失去穩定性(重啓電腦數據就會丟失)以及空間(受系統安裝內存條的數量限制，包括交換空間)。然而，有許多實用工具可以每隔一段時間備份虛擬硬盤裡面的數據，以及在關機前備份，然後在系統啓動時加載上次保存的數據。</p>
<h2>優點和缺點</h2>
<h3>優點</h3>
<ul><li>非常高的傳輸速度(從數據到應用)</li>
<li>非常低的尋道時間(在文件之間搜索)</li></ul>
<h3>缺點</h3>
<ul><li>在系統重啓時會清除虛擬硬盤的數據</li> 
 <li>如果世界尺寸大於內存條可用空間則很難實現</li></ul>
 
<h2>為什麼它對 Minecraft 服務器有意義</h2>
<p>在一個 Minecraft 服務器，最大的一個瓶頸是相關的磁盤 I/O 操作(如區塊管理)。通過向內存移動數據，訪問時間會被大大縮減，數據傳輸速度也會大大提高，讓區塊加載和保存區塊操作變得更快。因為一個 Minecraft 世界包含了許多區塊文件，尋道時間沒多大變化，因為重要的是整體速度。</p>

<h2>基礎 Minecraft 和虛擬硬盤安裝</h2>
<b>確保在開始前備份了你的文件！</b>

<h3>GNU/Linux(簡單方法)</h3>
<p>2011年3月12日，在Aimless Bits的博客里<br/> <a target="_self" rel="nofollow" class="external text" href="http://www.aimlessbits.com/?p=12">http://www.aimlessbits.com/?p=12</a>，<br/>發佈了把一個 Minecraft 服務器加載到虛擬硬盤的簡單方法。它包含了修改過的 Wiki 腳本，以及一些小更改。本指南充實了這一過程，並在 Aimless Bits 的腳本里做了一些小更改。</p>
<p>這個快速指南假設你已為加載 Minecraft 設定了一個用戶、Minecraft 目錄和運行中的服務器。它還有助於熟悉 /etc/init.d/minecraft 啓動腳本。</p>
<ul>
<li>第一步，在根目錄里為虛擬硬盤創建一個目錄。如「/home/username/minecraft_ramdisk」。</li>
<li>要將其掛載為一個虛擬硬盤，只需要簡單編輯你的 /etc/fstab/ 文件：</li>
</ul>
<pre>sudo nano /etc/fstab
</pre>
<p>然後添加這行，確保路徑(用戶名、目錄名稱等)是正確的。</p>
<pre>tmpfs  /home/username/minecraft_ramdisk tmpfs  defaults,size=512m      0       0
</pre>
<p>虛擬硬盤的尺寸必須比 Minecraft 的世界目錄還要大。確保你已經預留多了一些空間。</p>
<ul>
<li>重啓你的計算機。虛擬硬盤現在會在你重啓時加載，如果你希望立刻加載，輸入</li>
</ul>
<pre>mount -t tmpfs none /home/username/minecraft_ramdisk -o size=512m
</pre>
<p>現在要做的是簡單運行簡單修改過的腳本，該腳本會加載硬盤上的文件到服務器里，將它們複製幾次作為副本，以防止數據丟失。再次提醒，這個腳本是 Aimless Bits 腳本的修改版本。</p>
<p>如果你擁有 /etc/init.d/minecraft，刪除它或者將其覆蓋到這個腳本里。如果沒有，新建一個文本文檔，命名為「minecraft」，然後向它複製下列腳本內容。</p>
<pre>#!/bin/bash
# /etc/init.d/minecraft
# version 0.6 2012-02-25 (YYYY-MM-DD)

### BEGIN INIT INFO
# Provides:   minecraft
# Required-Start: $local_fs $remote_fs
# Required-Stop:  $local_fs $remote_fs
# Should-Start:   $network
# Should-Stop:    $network
# Default-Start:  2 3 4 5
# Default-Stop:   0 1 6
# Short-Description:    Minecraft server
# Description:    Starts the minecraft server
### END INIT INFO

#Settings
JARFILE='craftbukkit-beta_1.4.6-R0.3.jar'
USERNAME="minecraft"
MCSTORE="/home/$USERNAME/minecraft"
MCPATH="/home/$USERNAME/minecraft_ramdisk"
CPU_COUNT=1
INVOCATION="java -Xmx2048M -Xms2048M -server -jar $JARFILE -o false"
BACKUPPATH="/home/$USERNAME/minecraft_backups/"
WORLD=Asgarde


as_user() {
  if [ "`whoami`" == "$USERNAME" ] ; then
    bash -c "$1"
  else
    su - $USERNAME -c "$1"
  fi
}

mc_status() {
  ps aux |grep -F -v grep|grep -F -v SCREEN|grep -F --quiet $JARFILE
  return $?
}

mc_start() {
  if mc_status; then
    echo "Tried to start but $JARFILE was already running!"
  else
    echo "$JARFILE was not running... starting."
    if [ -d $MCSTORE/$WORLD.bak ]; then
      echo "last $WORLD.bak still exist, crashed warning! manual check required!!!"
      exit 1
    fi
    cd $MCPATH
    if [ ! -f "$MCPATH/$JARFILE" ]; then 
      echo "Ram drive empty...  prepping."
      as_user "cp -R $MCSTORE/* $MCPATH/"
    fi
    as_user "cd $MCPATH &amp;&amp; screen -dmS minecraft $INVOCATION"
    sleep 7
    if mc_status; then
      echo "$JARFILE is now running."
    else
      echo "Could not start $JARFILE."
    fi
  fi
}

mc_saveoff() {
  if mc_status; then
    echo "$JARFILE is running... suspending saves"
    TO_SCREEN="screen -p 0 -S minecraft -X eval 'stuff "
    as_user "$TO_SCREEN \"say SERVER BACKUP STARTING. Server going readonly...\"\015'"
    as_user "$TO_SCREEN \"save-off\"\015'"
    as_user "$TO_SCREEN \"save-all\"\015'"
    sync
    sleep 10
  else
    echo "$JARFILE was not running. Not suspending saves."
  fi
}

mc_saveon() {
  if mc_status; then
    echo "$JARFILE is running... re-enabling saves"
    TO_SCREEN="screen -p 0 -S minecraft -X eval 'stuff "
    as_user "$TO_SCREEN \"save-on\"\015'"
    as_user "$TO_SCREEN \"say SERVER BACKUP ENDED. Server going read-write...\"\015'"
  else
    echo "$JARFILE was not running. Not resuming saves."
  fi
}

mc_stop() {
  if mc_status; then
    echo "$JARFILE is running... stopping."
    TO_SCREEN="screen -p 0 -S minecraft -X eval 'stuff "
    as_user "$TO_SCREEN \"say SERVER SHUTTING DOWN IN 5 SECONDS. Saving map...\"\015'"
    as_user "$TO_SCREEN \"save-all\"\015'"
    sleep 5
    as_user "$TO_SCREEN \"stop\"\015'"
    sleep 5
  else
    echo "$JARFILE was not running."
  fi

  if mc_status; then
    echo "$JARFILE could not be shut down... still running."
  else
    echo "$JARFILE is shut down."
  fi
}


mc_update() {
  if mc_status; then
    echo "$JARFILE is running! Will not start update."
  else
    MC_SERVER_URL=https://minecraft.net/`wget -q -O - http://www.minecraft.net/download.jsp | grep minecraft_server.jar\&lt;/a\&gt; | cut -d \" -f 2`
    as_user "cd $MCPATH &amp;&amp; wget -q -O $MCPATH/minecraft_server.jar.update $MC_SERVER_URL"
    if [ -f $MCPATH/minecraft_server.jar.update ]; then
      if `diff $MCPATH/$JARFILE $MCPATH/minecraft_server.jar.update &gt;/dev/null`
     then 
       echo "You are already running the latest version of $JARFILE."
     else
       as_user "mv $MCPATH/minecraft_server.jar.update $MCPATH/$JARFILE"
       echo "Minecraft successfully updated."
      fi
    else
      echo "Minecraft update could not be downloaded."
    fi
  fi
}

mc_backup() {
   echo "Backing up minecraft files"
   as_user "tar zcf $BACKUPPATH/MCBKUP_`date "+%Y.%m.%d-%H"`.tar.gz $MCSTORE"
   echo "Backup complete"
}

mc_disksaverun() {
  if mc_status; then
    echo "Saving ramdrive to disk."
    if [ ! -f $MCPATH/$JARFILE ]; then
      echo "Error.. Minecraft not in ram"
    else
      if [ -d $MCSTORE/$WORLD.bak ]; then
        echo "last $WORLD.bak still exist, crashed warning! manual check required!!!"
        exit 1
      fi
      if [ -d $MCSTORE/$WORLD ]; then
        as_user "mv $MCSTORE/$WORLD $MCSTORE/$WORLD.bak"
      fi

      TO_SCREEN="screen -p 0 -S minecraft -X eval 'stuff "
      as_user "$TO_SCREEN \"save-off\"\015'"
      as_user "$TO_SCREEN \"save-all\"\015'" 
      as_user "cp -R $MCPATH/* $MCSTORE/"
      as_user "$TO_SCREEN \"save-on\"\015'"

      if [ -d $MCSTORE/$WORLD.bak ]; then
        as_user "rm -r $MCSTORE/$WORLD.bak"
      fi
    fi
  else
    echo "Service is not running"
 fi

}

mc_disksavehalt() {
   echo "Saving ramdrive to disk."
   if [ ! -f $MCPATH/$JARFILE ]; then 
     echo "Error.. Minecraft not in ram"
   else
     if [ -d $MCSTORE/$WORLD.bak ]; then
        echo "last $WORLD.bak still exist, crashed warning! manual check required!!!"
        exit 1
     fi
     if [ -d $MCSTORE/$WORLD ]; then
       as_user "mv $MCSTORE/$WORLD $MCSTORE/$WORLD.bak"
     fi

     echo "Saving, screen session closed"
     as_user "cp -R $MCPATH/* $MCSTORE/"

     if [ -d $MCSTORE/$WORLD.bak ]; then
       as_user "rm -r $MCSTORE/$WORLD.bak"
     fi
   fi
}


#Start-Stop here
case "$1" in
  start)
    mc_start
    ;;
  stop)
    mc_stop
    mc_disksavehalt
    ;;
  restart)
    mc_stop
    mc_disksavehalt
    mc_start
    ;;
  update)
    mc_stop
    mc_backup
    mc_update
    mc_start
    ;;
  backup)
    mc_disksaverun
    mc_saveoff
    mc_backup
    mc_saveon
    ;;
  disksavehalt)
    mc_disksavehalt
    ;;
  disksaverun)
    mc_disksaverun
    ;;
  status)
    if mc_status; then
      echo "$JARFILE is running."
    else
      echo "$JARFILE is not running."
    fi
    ;;
  *)
  echo "Usage: /etc/init.d/minecraft {start|stop|update|backup|status|restart|disksaverun}"
  exit 1
  ;;
esac
</pre>
<ul>
<li>把該腳本移動到你的 /etc/init.d/ directory，然後設置它為可執行：</li>
</ul>
<pre>mv /directory/wherefileis/filename /etc/init.d/minecraft
chmod a+x /etc/init.d/minecraft
</pre>
<p>注： <b>該腳本沒有寫上在 教程/服務器啓動腳本 的其他 minecraft 初始化腳本的命令行選項！</b> 因此重寫了該腳本，加入了一些命令代碼，因此虛擬硬盤服務器也可以使用命令之類去同步而不用使用其他插件來進行計劃：<a target="_self" rel="nofollow" class="external free" href="http://pastebin.com/4ynwL2js">http://pastebin.com/4ynwL2js</a> 。如果需要命令行選項，可以使用這個。</p>
<p>你就快完成了！這個腳本表現的和原始的啓動腳本差不多，只有一點不同的就是它把數據加載到虛擬硬盤里。你也可以修改腳本來使用 rsync 而不是 cp。</p>
<pre>"rsync -r -t $MCSTORE/ $MCPATH/"
</pre>
<p>如果你想做其他東西，例如遠程複製，但這對性能沒什麼影響，除非你的世界很大。</p>
<ul>
<li><b>請勿跳過這個步驟！</b>你需呀添加一個 crontab 條目來保存你的世界。因為某些原因，你要接著往下看，但是如果你不完成這個步驟，那麼你在虛擬硬盤里的數據就會丟失。該腳本有2個磁盤保存函數，disksavehalt 和 disksaverun。 Disksavehalt 指定 screen 會話正在關閉還是正在備份，不會關閉地圖保存。不要在 crontab 里調用這個函數，而是使用 disksave。做這個：</li>
</ul>
<pre>sudo crontab -e
</pre>
<p>然後添加下面2行：</p>
<pre>*/5 * * * * /etc/init.d/minecraft disksaverun
20 */6 * * * /etc/init.d/minecraft backup
</pre>
<p>數字代表每隔多少分鐘就保存世界，如果你喜歡一個強健的安裝、有力的供給備份以及工作，就減少這個數字。這個間隔最低只能為5分鐘。</p>
<p>其他行運行 Minecraft 會每隔6小時備份一次，並且固定在:20時進行備份。不要跳過備份！這是最後一次警告！</p>
<p>但願這能夠對管理員有幫助，祝你好運！</p>


<h3>GNU/Linux(備選方法)</h3>
<p>在多數的 GNU/Linux 發行版，虛擬硬盤已經設置好了(通常掛載在 /dev/shm (<b>sh</b>ared <b>m</b>emory(共享的內存)))，默認最多使用已安裝內存的一半) 如果未設置，互聯網上有許多資源教你如何設置。</p>
<p>可以把任何東西移到虛擬硬盤，但本教程只專注於把地圖移動到虛擬硬盤里，並將服務器文件留在傳統驅動器上。</p>
<p>在用戶根目錄里的「minecraft_server/」服務器目錄里分成下面幾個基本文件，含有世界「world」和其他所需要的文件。</p>
<table >
<tr>
<th>~/minecraft_server/</th>
</tr>
<tr>
<td>world/</td>
</tr>
<tr>
<td>minecraft_server.jar</td>
</tr>
<tr>
<td>server.log</td>
</tr>
<tr>
<td>server.properties</td>
</tr>
<tr>
<td>...</td>
</tr>
</table>
<p>接下來的目標是把「world/」移動到共享內存里。由於虛擬硬盤的不穩定性，我們要創建一個新文件夾，在裡面放上一個自動備份的腳本，通過複製當前目錄到一個新名稱目錄來定期儲存當前世界的名為(例如)「world_storage」的快照。</p>
<pre>$ cd ~/minecraft_server/
$ cp -r world/ world_storage/
</pre>
<p>現在舊世界在一個安全位置里，我們現在可以進行下一步並將世界移動到虛擬硬盤。</p>
<pre>$ mkdir /dev/shm/minecraft
$ mv world/ /dev/shm/minecraft
</pre>
<p>現在，世界以及加載到內存里，但是 Minecraft 服務器還是沒有在它的目錄里看見這個世界，導致在啓動時會重新生成它。為了阻止服務器生成它，我們要在虛擬硬盤里創造一個符號鏈接到那個世界。運行下列命令：</p>
<pre>$ ln -s /dev/shm/minecraft/world/ 
</pre>
<p>這將會創建一個名為「world/」的鏈接，其鏈接到服務器目錄「/dev/shm/minecraft/world/」，服務器會把它當作實際的世界文件夾使用，但是這個文件夾在內存里。</p>
<p>現在我們需要注意虛擬硬盤的不穩定性，要定期保存內存「world_storage/」裡面的世界。下面將使用 cron 進行計劃任務和 rsync 進行同步。</p>
<p>首先，創建一個叫作 cron 的腳本(它不能是一個腳本，因為你可以直接從 cron 命令行直接調用 rsync，但這樣允許在晚些時候更容易的進行自定義)</p>
<pre>#!/bin/sh

VOLATILE="/home/$USER/minecraft_server/world/"
PERMANENT="/home/$USER/minecraft_server/world_storage/"

#TODO: Check if both directories actually exist, skipped here for clearness
rsync -r -t -v "$VOLATILE" "$PERMANENT"
</pre>
<p>然後每隔幾分鐘運行該腳本(這裡將會隔5分鐘，你可以測試一下隔多長時間對你是最合適的)</p>
<pre>$ crontab -e
</pre>
<p>你將會被帶到一個編輯器(更精確的說：你的「EDITOR」環境變量編輯器)來編輯你的用戶 cron 表。添加下列行：</p>
<pre>*/5 * * * * bash /home/&lt;your_username&gt;/minecraft_server/save_world.sh &amp;&gt;/dev/null
</pre>
<p>現在你的服務器將會重啓，你將會在晚些時候在共享內存里(/dev/shm/minecraft/world)重新創建世界文件夾(/dev/shm/minecraft)，因為重啓後 /dev/shm/ 是空的。你可以寫一個簡單的可執行腳本來做到這點。</p>
<p>因此製作一個簡單的可執行腳本：</p>
<pre>exec 1&gt;/tmp/backup_world.log 2&gt;&amp;1 #sends the output to this file
#!/bin/sh
#remake the paths
mkdir /dev/shm/minecraft
mkdir /dev/shm/minecraft/world

VOLATILE="/home/$USER/minecraft_server/world/"
PERMANENT="/home/$USER/minecraft_server/world_storage/"

#TODO: Check if both directories actually exist, skipped here for clearness
#reversed the order
rsync -r -t -v "$PERMANENT" "$VOLATILE"
</pre>
<p>每次你重啓時，你都要運行這個腳本來重新掛載虛擬硬盤。不要把這個添加到 crontab 里。如果你找出了答案，那麼你可以添加這個到 start up。</p>


<h3>Windows</h3>
<p>使用一個像Dataram RAMDisk之類的虛擬硬盤實用工具來在內存中創建一個磁盤(下載免費的版本)之類的虛擬硬盤實用工具來在內存中創建一個磁盤，<br /> <a target="_self" rel="nofollow" class="external text" href="http://memory.dataram.com/products-and-services/software/ramdisk">http://memory.dataram.com/products-and-services/software/ramdisk</a><br />並將服務器文件放進裡面。 <i>Dataram RAMDisk</i> 提供了在其關閉的時候或隔幾分鐘自動保存圖像的選項。</p>
<p><b>開始之前：</b></p>
<ul>
<li>至少要4G內存</li>
<li>開啓「關機時保存磁盤映像」，在關機時停止虛擬硬盤的運行會對 Windows 關機時間造成影響，同時也會對開機時間造成影響，因為要「在啓動時加載磁盤映像」。如果你僅在需要時手動啓動或停止服務器，那麼這就不成問題了。</li>
<li>在網絡上進行搜索保存虛擬硬盤數據的方法，以防你的虛擬硬盤不能工作時丟失數據。</li>
<li>FAT16 格式的虛擬硬盤<i>通常</i>比 FAT32 的要快，然而 FAT16 格式不允許單個磁盤容量超過 2048 MB。</li>
<li>記住：<b>經常備份！</b>如果你的電腦崩掉了，任何未保存的虛擬硬盤數據都會丟失！</li>
<li>確保你為虛擬硬盤分配了足夠的空間，可以裝得下「Minecraft Server」文件夾 - 記得 Minecraft 世界數據可以增加很多！</li>
<li>...最後，確保剩餘的內存空間足夠讓 Windows 和服務器本身運行</li>
</ul>
<p><b>設置你的虛擬硬盤(簡單用法)</b></p>
<ol>
<li>下載並安裝  Dataram RAMDisk </li>
<li>設置硬盤尺寸(不推薦設置到最大)</li>
<li>如果硬盤尺寸少於等於 2048 MB，選擇「FAT16 Partition」否則就選「FAT32 Partition」(高級用戶可能會選擇「unformatted」並手動格式化硬盤)</li>
<li>前往 Load/Save 標籤頁，並選擇所有3種虛擬硬盤保存方法(「AutoSave」、「Save Disk Image on Shutdown」和「Load Disk Image on Startup」)</li>
<li>要啓動你的虛擬硬盤 - 點擊「Start RAMDisk」</li>
<li>現在前往「計算機」(Win XP 為我的電腦、Win 7、Win 10 為計算機、Win 8 為此計算機)，你應該會看見新的硬盤</li>
<li>打開它並複製所有的 Minecraft 服務器到這個硬盤里。</li>
<li>像平常一樣啓動你的服務器，只不過現在是從剛剛創建的虛擬硬盤啓動 - 你現在就能啓動和運行了！</li>
</ol>
<p>你的虛擬硬盤現在會在關機時自動保存，並在開機時自動加載。你會注意到開機/關機的時間更長了，而增加的時間取決於你設置的尺寸。</p>
<p>同時，你可能希望調整 AutoSave (自動保存)間隔。</p>
<p><b>如果你沒有選擇「Save Disk Image on Shutdown」，繼續看下去！</b></p>
<p>你需要在'<i>每次'</i><b>關閉計算機</b>時完成下列步驟，否則<b>數據就會丟失</b>！</p>
<dl>
<dd><b>手動停止虛擬硬盤(在關閉計算機之前)</b>
<ol>
<li>如果你的 Minecraft 服務器正在運行，停止它</li>
<li>打開 Dataram RAMDisk configuration Utility(再次)</li>
<li>在 Load/save 標籤頁開啓「Load Disk Image on Startup」</li>
<li>點擊「Save disk image now」</li>
<li>點擊「Stop RAMDisk」</li>
</ol>
</dd>
<dd>(如果你希望再次啓動服務器，按照你第一次啓動服務器的操作去做。如果你勾選了「Load Disk Image at Startup」才能做這個)</dd>
<dd><b>備選方法：</b>
<ol>
<li>停止你的服務器</li>
<li>複製虛擬硬盤里的所有文件到硬盤驅動器的一個備份文件夾</li>
<li>在 Dataram RAMDisk configuration Utility 點擊「Stop RAMDisk」</li>
</ol>
</dd>
<dd>(要再次啓動它，按照你第一次啓動虛擬硬盤的操作去做，然後把所有文件複製到虛擬硬盤里，然後啓動你的服務器。)</dd>
</dl>


<h3>Mac OS X</h3>
<p>在 Mac OS 里鍵入下列命令來創建你的虛擬硬盤：</p>
<pre>diskutil erasevolume HFS+ "ramdisk" `hdiutil attach -nomount ram://1165430`
</pre>
<p>這只有一條命令行，而且還很快，很有效果。&#160;:)</p>
<p>如果你跟隨這些操作去做了，你的虛擬硬盤將會出現在 /Volumes/ramdisk。在此之後，按照你在 Linux 那樣做，使用 Terminal 和你喜愛的文字編輯器。</p>
        


<p><br/></p></div>
</body>

</html>
